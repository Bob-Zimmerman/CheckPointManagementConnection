//
//  CPM Connection.swift
//  CheckPointManagementConnection
//
//  Created by Bob Zimmerman on 2024-12-10.
//

import Foundation
import os

public actor CheckPointManagement {
	public static let logger = Logger(subsystem: "ChkpMgmt", category: "API Connection")
	public nonisolated let cpmURL: URL
	public nonisolated let cpmUsername: String
	public nonisolated let apiVersion: String
	public nonisolated let readOnly: Bool
	internal let cpmAPISession: URLSession
	internal let cpmJSONDecoder = JSONDecoder()
	internal var timer: Timer?
	
	internal init(
		serverUrl: URL,
		loginBody: [String: Sendable])
	async throws {
		guard (loginBody["user"], loginBody["password"]) is (String, String)
				|| (loginBody["api-key"] is String) else {
			CheckPointManagement.logger.error("ERROR: Couldn't get user/pass or API key from the login body.")
			throw CPMError.badCredentials }
		CheckPointManagement.logger.debug("DEBUG: Object initialized at \(Date().description, privacy: .public)")
		self.cpmURL = serverUrl.appendingPathComponent("web_api")
		
		let cpmSessionConfig = URLSessionConfiguration.default
		cpmSessionConfig.httpAdditionalHeaders = ["Content-Type": "application/json"]
		let loginSession = URLSession(configuration: cpmSessionConfig)
		
		let apiPoint = "/login"
		let request = NSMutableURLRequest(url: self.cpmURL.appendingPathComponent(apiPoint))
		request.httpMethod = "POST"
		request.httpBody = try JSONSerialization.data(withJSONObject: loginBody)
		let returnedData = try CheckPointManagement.handleApiReturnErrors(await loginSession.data(for: request as URLRequest))
		let decoded: CPMLoginResponse = try cpmJSONDecoder.decode(CPMLoginResponse.self, from: returnedData)
		cpmSessionConfig.httpAdditionalHeaders?["X-Chkp-Sid"] = decoded.sid
		self.apiVersion = decoded.apiServerVersion
		(self.cpmUsername, self.readOnly) = try CheckPointManagement.getUserData(loginBody, response: decoded)
		self.cpmAPISession = URLSession(configuration: cpmSessionConfig)
		CheckPointManagement.logger.debug("DEBUG: /login returned: \(String(describing: String(data: returnedData, encoding: .utf8)), privacy: .public)")
		timer = Timer.scheduledTimer(withTimeInterval: 60.0, repeats: true) { _ in
			Task { try? await self.keepalive() } }
		timer?.tolerance = 10.0
	}
	
	/// Log in with a username and password.
	///
	/// - Parameters:
	///   - url: A URL object for the server you want to log in to. This should just be the scheme,
	///   domain name, and any proxy path, but without the 'web_api'.
	///   - domain: This lets you log in to a specific domain, such as "System Data" on a SmartCenter
	///   or any of the domains on an MDS.
	///   - username: Username. This is case-sensitive.
	///   - password: User's password.
	///   - readOnly: Connect in read-only mode. Defaults to true.
	public init(
		url: URL,
		domain: String? = nil,
		username: String,
		password: String,
		readOnly: Bool = true)
	async throws {
		let loginBody: [String: Sendable] = [
			"domain": domain ?? "",
			"user": username,
			"password": password,
			"read-only": readOnly]
		try await self.init(serverUrl: url,
							loginBody: loginBody)
	}
	
	/// Log in with an API key.
	///
	/// - Parameters:
	///   - url: A URL object for the server you want to log in to. This should just be the scheme,
	///   domain name, and any proxy path, but without the 'web_api'.
	///   - domain: This lets you log in to a specific domain, such as "System Data" on a SmartCenter
	///   or any of the domains on an MDS.
	///   - apiKey: The API key as a string, as generated by the /add-api-key call.
	///   - readOnly: Connect in read-only mode. Defaults to true.
	public init(
		url: URL,
		domain: String? = nil,
		apiKey: String,
		readOnly: Bool = true)
	async throws {
		let loginBody: [String: Sendable] = [
			"domain": domain ?? "",
			"api-key": apiKey,
			"read-only": readOnly]
		try await self.init(serverUrl: url,
							loginBody: loginBody)
	}
	
	/// Handle errors within the API response.
	///
	/// This is carved off to a separate function to allow better test coverage. It is expected to have high
	/// cyclomatic complexity, since it needs to be able to identify a lot of distinct errors. Each code path
	/// should be relatively simple, handling only a specific type of error.
	///
	/// - Parameters:
	///   - returned: The tuple returned by URLSession.data(for: URLRequest)
	///
	/// - Returns: The data from the URLSession
	// swiftlint:disable:next cyclomatic_complexity function_body_length
	internal static func handleApiReturnErrors(_ returned: (data: Data, response: URLResponse))
	throws -> Data {
		guard let response = returned.response as? HTTPURLResponse else {
			CheckPointManagement.logger.error("ERROR: Couldn't convert API call response to an HTTP URL Response")
			throw DecodingError.typeMismatch(HTTPURLResponse.self, DecodingError.Context(
				codingPath: [], debugDescription: "Couldn't convert API call response to an HTTP URL Response")) }
		let apiError = try? JSONDecoder().decode(CPMApiError.self, from: returned.data)
		
		// TODO: Get error exemplars and make more robust error handling.
		// Check Point doesn't seem to use HTTP return codes consistently.
		switch (response.statusCode, apiError?.code, apiError?.message) {
		case (200, nil, nil):
			return returned.data
		case (500, "generic_error", "Authentication to server failed."),
			(400, "err_login_failed", "Authentication to server failed."):
			throw CPMError.badCredentials
		case (500, "generic_error", "Administrator account is locked."),
			(400, "err_login_failed", "Administrator account is locked."):
			throw CPMError.accountLocked
		case (500, "generic_error", let message)
			where message?.hasSuffix("failed. Check that you have permission to login through API") == true,
			(400, "err_login_failed", let message)
			where message?.hasSuffix("failed. Check that you have permission to login through API") == true:
			throw CPMError.connectionProhibited
		case (400, "err_unknown_api_version", let message) where message?.hasPrefix("Unknown API version:") == true:
			throw CPMError.unknownApiVersion
		case (503, nil, nil):
			throw CPMError.apiDown
		case (404, let code, let message):
			CheckPointManagement.logger.debug("DEBUG: invalid object. Code: \(String(describing: code), privacy: .public), message: \(String(describing: message), privacy: .public).")
			throw CPMError.invalidObject
		case (500, "generic_error", let message) where message?.hasPrefix("Validation failed") == true,
			(400, "err_validation_failed", let message) where message?.hasPrefix("Validation failed") == true:
			var userInfo = [NSLocalizedDescriptionKey: apiError?.code,
					 NSLocalizedFailureReasonErrorKey: apiError?.message]
			if let errors = apiError?.errors, !errors.isEmpty {
				userInfo[NSUnderlyingErrorKey] = String(errors.reduce("") { $0 + "\n" + $1.message }.dropFirst()) }
			let toThrow = NSError(domain: CPMError.validationFailed.domain,
								  code: CPMError.validationFailed.code,
								  userInfo: userInfo as [String: Any])
			throw toThrow
		case (500, "err_policy_installation_failed", let message),
			(409, "err_policy_installation_failed", let message):
			var userInfo = [NSLocalizedDescriptionKey: apiError?.code,
					 NSLocalizedFailureReasonErrorKey: message]
			let toThrow = NSError(domain: CPMError.policyInstallationFailed.domain,
								  code: CPMError.policyInstallationFailed.code,
								  userInfo: userInfo as [String: Any])
			throw toThrow
		default:
			CheckPointManagement.logger.error("ERROR: URL Session Task for \(String(describing: response.url?.absoluteString), privacy: .public) failed: HTTP \(response.statusCode, privacy: .public).")
			CheckPointManagement.logger.error("ERROR: Fetched data:")
			CheckPointManagement.logger.error("\(String(describing: String(data: returned.data, encoding: .utf8)))")
			guard let apiError = apiError else { throw CPMError.unknownError }
			var userInfo = [NSLocalizedDescriptionKey: apiError.code,
					 NSLocalizedFailureReasonErrorKey: apiError.message]
			if let errors = apiError.errors, !errors.isEmpty {
				userInfo[NSUnderlyingErrorKey] = String(errors.reduce("") { $0 + "\n" + $1.message }.dropFirst()) }
			let toThrow = NSError(domain: CPMError.unknownError.domain,
								  code: CPMError.unknownError.code,
								  userInfo: userInfo as [String: Any])
			throw toThrow
		}
	}
	
	/// Get user and read-only status from either the login request or response.
	///
	/// This is carved off to a separate function to allow better test coverage.
	///
	/// Logging in with an API key doesn't involve putting a username in the request. Instead, we get it
	/// from the response. But if a username is provided in the request, it isn't always returned in the
	/// response. The read-only key doesn't need to be included in the request at all, but is typically
	/// included in the response.
	internal static func getUserData(
		_ loginBody: [String: Sendable],
		response: CPMLoginResponse)
	throws -> (username: String, readOnly: Bool) {
		guard let username = (loginBody["user"] as? String ?? response.username),
			  let readOnly = (loginBody["read-only"] as? Bool ?? response.readOnly) else {
			CheckPointManagement.logger.error("ERROR: Couldn't get username and read-only from login body or return.")
			throw CPMError.unknownError }
		return (username, readOnly)
	}
	
	/// Make an API call directly.
	///
	/// - Parameters:
	///   - apiPoint: The point in the API which you want to call.
	///   - requestBody: A JSON-compatible dictionary of the message you want to send to the API point.
	///
	/// - Returns: The Data object from the server's response.
	public func makeRawApiCall(
		apiPoint: String,
		requestBody: [String: Sendable])
	async throws -> Data {
		CheckPointManagement.logger.trace("Entering makeRawApiCall for \(apiPoint, privacy: .public), request body: \(requestBody, privacy: .private)")
		let request = NSMutableURLRequest(url: self.cpmURL.appendingPathComponent(apiPoint))
		request.httpMethod = "POST"
		request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
		let returnedData = try CheckPointManagement.handleApiReturnErrors(
			await cpmAPISession.data(for: request as URLRequest))
		CheckPointManagement.logger.debug("DEBUG: \(apiPoint, privacy: .public) returned: \(String(describing: String(data: returnedData, encoding: .utf8)), privacy: .public)")
		return returnedData
	}
	
	/// Call the keepalive API point to keep your session from timing out.
	///
	/// You should never need to call this directly. It is called by the timer every 60 seconds by default.
	public func keepalive() async throws {
		_ = try await makeRawApiCall(apiPoint: "/keepalive", requestBody: [:])
	}
	
	/// Log out from the management server.
	public func logout() async throws {
		_ = try await makeRawApiCall(apiPoint: "/logout", requestBody: [:])
		timer?.invalidate()
	}
	
	/// A function to cause the timer to fire for test purposes.
	internal func fireTimer() {
		timer?.fire()
	}
}
