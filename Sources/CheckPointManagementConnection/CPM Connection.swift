//
//  CPM Connection.swift
//  CheckPointManagementConnection
//
//  Created by Bob Zimmerman on 2024-12-10.
//

import Foundation
import os

actor CheckPointManagement {
	public static let logger = Logger(subsystem: "ChkpMgmt", category: "API Connection")
	public let cpmURL: URL
	public let cpmUsername: String
	public let apiVersion: String
	public let readOnly: Bool
	internal let cpmAPISession: URLSession
	internal let cpmJSONDecoder: JSONDecoder = {
		let decoder = JSONDecoder()
		decoder.dateDecodingStrategy = JSONDecoder.DateDecodingStrategy.millisecondsSince1970
		return decoder }()
	internal var timer: Timer?
	
	internal init(
		serverUrl: URL,
		loginBody: [String: Sendable])
	async throws {
		guard (loginBody["user"], loginBody["password"]) is (String, String)
				|| (loginBody["api-key"] is String) else {
			CheckPointManagement.logger.error("ERROR: Couldn't get user/pass or API key from the login body.")
			throw CPMError.badCredentials }
		CheckPointManagement.logger.debug("DEBUG: Object initialized at \(Date().description, privacy: .public)")
		self.cpmURL = serverUrl.appendingPathComponent("web_api")
		
		let cpmSessionConfig = URLSessionConfiguration.default
		cpmSessionConfig.httpAdditionalHeaders = ["Content-Type": "application/json"]
		let loginSession = URLSession(configuration: cpmSessionConfig)
		
		let apiPoint = "/login"
		let request = NSMutableURLRequest(url: self.cpmURL.appendingPathComponent(apiPoint))
		request.httpMethod = "POST"
		request.httpBody = try JSONSerialization.data(withJSONObject: loginBody)
		let returnedData = try CheckPointManagement.handleApiReturnErrors(await loginSession.data(for: request as URLRequest))
		let decoded: CPMLoginResponse = try cpmJSONDecoder.decode(CPMLoginResponse.self, from: returnedData)
		cpmSessionConfig.httpAdditionalHeaders?["X-Chkp-Sid"] = decoded.sid
		self.apiVersion = decoded.apiServerVersion
		(self.cpmUsername, self.readOnly) = try CheckPointManagement.getUserData(loginBody, response: decoded)
		self.cpmAPISession = URLSession(configuration: cpmSessionConfig)
		CheckPointManagement.logger.debug("DEBUG: /login returned: \(String(describing: String(data: returnedData, encoding: .utf8)), privacy: .public)")
		timer = Timer.scheduledTimer(withTimeInterval: 60.0, repeats: true) { _ in
			Task { try? await self.keepalive() } }
		timer?.tolerance = 10.0
	}
	
	/// Log in with a username and password.
	///
	/// - Parameters:
	///   - url: A URL object for the server you want to log in to. This should just be the scheme,
	///   domain name, and any proxy path, but without the 'web_api'.
	///   - domain: This lets you log in to a specific domain, such as "System Data" on a SmartCenter
	///   or any of the domains on an MDS.
	///   - username: Username. This is case-sensitive.
	///   - password: User's password.
	///   - readOnly: Connect in read-only mode. Defaults to true.
	init(
		url: URL,
		domain: String? = nil,
		username: String,
		password: String,
		readOnly: Bool = true)
	async throws {
		let loginBody: [String: Sendable] = [
			"domain": domain ?? "",
			"user": username,
			"password": password,
			"read-only": readOnly]
		try await self.init(serverUrl: url,
							loginBody: loginBody)
	}
	
	/// Log in with an API key.
	///
	/// - Parameters:
	///   - url: A URL object for the server you want to log in to. This should just be the scheme,
	///   domain name, and any proxy path, but without the 'web_api'.
	///   - domain: This lets you log in to a specific domain, such as "System Data" on a SmartCenter
	///   or any of the domains on an MDS.
	///   - apiKey: The API key as a string, as generated by the /add-api-key call.
	///   - readOnly: Connect in read-only mode. Defaults to true.
	init(
		url: URL,
		domain: String? = nil,
		apiKey: String,
		readOnly: Bool = true)
	async throws {
		let loginBody: [String: Sendable] = [
			"domain": domain ?? "",
			"api-key": apiKey,
			"read-only": readOnly]
		try await self.init(serverUrl: url,
							loginBody: loginBody)
	}
	
	/// Handle errors within the API response.
	///
	/// This is carved off to a separate function to allow better test coverage.
	///
	/// - Parameters:
	///   - returned: The tuple returned by URLSession.data(for: URLRequest)
	///
	/// - Returns: The data from the URLSession
	internal static func handleApiReturnErrors(_ returned: (data: Data, response: URLResponse))
	throws -> Data {
		guard let response = returned.response as? HTTPURLResponse else {
			CheckPointManagement.logger.error("ERROR: Couldn't convert API call response to an HTTP URL Response")
			throw DecodingError.typeMismatch(HTTPURLResponse.self, DecodingError.Context(
				codingPath: [], debugDescription: "Couldn't convert API call response to an HTTP URL Response")) }
		// TODO: Get error exemplars and make more robust error handling.
		// Check Point doesn't seem to use HTTP return codes consistently.
		switch response.statusCode {
		case 200:
			return returned.data
		case 400:
			throw CPMError.badCredentials
		case 403:
			throw CPMError.connectionProhibited
		case 404:
			throw CPMError.invalidObject
		case 503:
			throw CPMError.apiDown
		default:
			CheckPointManagement.logger.error("ERROR: URL Session Task for \(String(describing: response.url?.absoluteString), privacy: .public) failed: HTTP \(response.statusCode, privacy: .public).")
			CheckPointManagement.logger.error("ERROR: Fetched data:")
			CheckPointManagement.logger.error("\(String(describing: String(data: returned.data, encoding: .utf8)))")
			throw CPMError.unknownError
		}
	}
	
	/// Get user and read-only status from either the login request or response.
	///
	/// This is carved off to a separate function to allow better test coverage.
	///
	/// Logging in with an API key doesn't involve putting a username in the request. Instead, we get it
	/// from the response. But if a username is provided in the request, it isn't always returned in the
	/// response. The read-only key doesn't need to be included in the request at all, but is typically
	/// included in the response.
	internal static func getUserData(
		_ loginBody: [String: Sendable],
		response: CPMLoginResponse)
	throws -> (username: String, readOnly: Bool) {
		guard let username = (loginBody["user"] as? String ?? response.username),
			  let readOnly = (loginBody["read-only"] as? Bool ?? response.readOnly) else {
			CheckPointManagement.logger.error("ERROR: Couldn't get username and read-only from login body or return.")
			throw CPMError.unknownError }
		return (username, readOnly)
	}
	
	/// Make an API call directly.
	///
	/// - Parameters:
	///   - apiPoint: The point in the API which you want to call.
	///   - requestBody: A JSON-compatible dictionary of the message you want to send to the API point.
	///
	/// - Returns: The Data object from the server's response.
	public func makeRawApiCall(
		apiPoint: String,
		requestBody: [String: Sendable])
	async throws -> Data {
		CheckPointManagement.logger.trace("Entering makeRawApiCall for \(apiPoint, privacy: .public), request body: \(requestBody, privacy: .private)")
		let request = NSMutableURLRequest(url: self.cpmURL.appendingPathComponent(apiPoint))
		request.httpMethod = "POST"
		request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
		let returnedData = try CheckPointManagement.handleApiReturnErrors(
			await cpmAPISession.data(for: request as URLRequest))
		CheckPointManagement.logger.debug("DEBUG: \(apiPoint, privacy: .public) returned: \(String(describing: String(data: returnedData, encoding: .utf8)), privacy: .public)")
		return returnedData
	}
	
	/// Call the keepalive API point to keep your session from timing out.
	///
	/// You should never need to call this directly. It is called by the timer every 60 seconds by default.
	public func keepalive() async throws {
		_ = try await makeRawApiCall(apiPoint: "/keepalive", requestBody: [:])
	}
	
	/// Log out from the management server.
	public func logout() async throws {
		_ = try await makeRawApiCall(apiPoint: "/logout", requestBody: [:])
		timer?.invalidate()
	}
	
	/// A function to cause the timer to fire for test purposes.
	internal func fireTimer() {
		timer?.fire()
	}
}
